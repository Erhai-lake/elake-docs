import{_ as o,c as E,a4 as t,b as p,w as a,a5 as r,j as i,a as n,B as k,o as e,G as h}from"./chunks/framework.BPErc-vJ.js";const d="/assets/72c5656c1e15a695fb3a3a96ec3381cd2487fb2e.CUZZLtOu.png",C=JSON.parse('{"title":"JS执行机制","description":"","frontmatter":{},"headers":[],"relativePath":"Docs/Knowledge/ProgrammingLanguage/JavaScript/JsExecutionMechanism.md","filePath":"Docs/Knowledge/ProgrammingLanguage/JavaScript/JsExecutionMechanism.md","lastUpdated":1727545103000}'),c={name:"Docs/Knowledge/ProgrammingLanguage/JavaScript/JsExecutionMechanism.md"};function g(m,s,u,b,y,F){const l=k("Mermaid");return e(),E("div",null,[s[2]||(s[2]=t(`<h1 id="js执行机制" tabindex="-1">JS执行机制 <a class="header-anchor" href="#js执行机制" aria-label="Permalink to &quot;JS执行机制&quot;">​</a></h1><h2 id="经典面试题" tabindex="-1">经典面试题 <a class="header-anchor" href="#经典面试题" aria-label="Permalink to &quot;经典面试题&quot;">​</a></h2><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 问:输出的顺序是什么</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 答1,3,2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>延时了1秒钟,所以是132,合理</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 问:输出的顺序是什么</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 答1,3,2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>为什么延时0秒,不应该是立即执行么,怎么还是132?</p><h2 id="线程" tabindex="-1">线程 <a class="header-anchor" href="#线程" aria-label="Permalink to &quot;线程&quot;">​</a></h2><p>JavaScript语言的一大特点就是<strong>单线程</strong>,也就是说,<strong>同一时间只能做一件事</strong></p><p>:::note 这是因为JavaScript这门脚本语言诞生的使命所致的</p><p>JavaScript是为处理页面中用户的交互,以及操作DOM而诞生的.比如我们对某个DOM元素进行添加和删除操作,不能同时进行.应该先添加,之后再删除</p><p>单线程就意味着,所有任务需要排队,前一个任务结束,才会执行后一个任务.这样所导致的问题是:</p><p>如果JS执行的时间过长,就会造成页面渲染不连贯,导致页面渲染加载堵塞感</p><p>为了解决这个问题,利用多核CPU的算力,Html5提出Web Worker标准,运行JavaScript脚本创建多个线程.于是,JS中出现了<strong>同步</strong>和<strong>异步</strong> :::</p><h3 id="同步" tabindex="-1">同步 <a class="header-anchor" href="#同步" aria-label="Permalink to &quot;同步&quot;">​</a></h3><p>前一个任务结束后再执行后一个任务,程序的执行顺序与任务的排队顺序是一致的,同步的.举个例子</p><p>洗米花费5分钟,煮饭花费40分钟,饭熟了才去切菜花费5分钟,炒菜花费30分钟,一共花费了1个小时30分钟.看不懂?上图!</p>`,16)),(e(),p(r,null,{default:a(()=>[h(l,{id:"mermaid-44",class:"mermaid",graph:"flowchart%20TD%3B%E6%B4%97%E7%B1%B35%E5%88%86%E9%92%9F%20--%3E%20%E7%85%AE%E9%A5%AD40%E5%88%86%E9%92%9F%20--%3E%20%E5%88%87%E8%8F%9C5%E5%88%86%E9%92%9F%20--%3E%20%E7%82%92%E8%8F%9C30%E5%88%86%E9%92%9F%20--%3E%20%E6%80%BB%E8%AE%A11%E5%B0%8F%E6%97%B620%E5%88%86%E9%92%9F%0A"})]),fallback:a(()=>s[0]||(s[0]=[n(" Loading... ")])),_:1})),s[3]||(s[3]=i("h3",{id:"异步",tabindex:"-1"},[n("异步 "),i("a",{class:"header-anchor",href:"#异步","aria-label":'Permalink to "异步"'},"​")],-1)),s[4]||(s[4]=i("p",null,"你在做一件事情时,因为这件事情会花费很长时间,在做这件事的同时,可以去处理其他事情.举个例子",-1)),s[5]||(s[5]=i("p",null,"洗米花费5分钟,煮饭花费40小时,饭还有35分钟熟的时候,去切菜花费5分钟,炒菜花费30分钟,这时饭刚好熟了,一共花费了45个小时.看不懂?上图!",-1)),(e(),p(r,null,{default:a(()=>[h(l,{id:"mermaid-54",class:"mermaid",graph:"flowchart%20TD%3B%E6%B4%97%E7%B1%B35%E5%88%86%E9%92%9F%20--%3E%20%E7%85%AE%E9%A5%AD40%E5%88%86%E9%92%9F%20--%3E%20%E6%80%BB%E8%AE%A145%E5%88%86%E9%92%9F%3B%E7%85%AE%E9%A5%AD40%E5%88%86%E9%92%9F%20--%3E%20%E5%88%87%E8%8F%9C5%E5%88%86%E9%92%9F%20--%3E%20%E7%82%92%E8%8F%9C30%E5%88%86%E9%92%9F%20--%3E%20%E6%80%BB%E8%AE%A145%E5%88%86%E9%92%9F%0A"})]),fallback:a(()=>s[1]||(s[1]=[n(" Loading... ")])),_:1})),s[6]||(s[6]=t('<h3 id="本质" tabindex="-1">本质 <a class="header-anchor" href="#本质" aria-label="Permalink to &quot;本质&quot;">​</a></h3><p>同步和异步本质就是执行顺序的不同</p><h3 id="同步任务" tabindex="-1">同步任务 <a class="header-anchor" href="#同步任务" aria-label="Permalink to &quot;同步任务&quot;">​</a></h3><p>同步任务都是在主线程上执行,形成一个<strong>执行栈</strong></p><h3 id="异步任务" tabindex="-1">异步任务 <a class="header-anchor" href="#异步任务" aria-label="Permalink to &quot;异步任务&quot;">​</a></h3><p>JS的异步是通过回调函数实现的</p><p>一般而言,异步任务有以下3种类型</p><ol><li>普通事件,如<code>click</code>,<code>resize</code>等</li><li>资源加载,如<code>load</code>,<code>error</code>等</li><li>定时器,包括<code>setInterval</code>,<code>setTimeout</code>等</li></ol><p>异步任务相关添加到<strong>任务队列</strong>中(任务队列也称为<strong>消息队列</strong>)</p><h2 id="机制" tabindex="-1">机制 <a class="header-anchor" href="#机制" aria-label="Permalink to &quot;机制&quot;">​</a></h2><ol><li>先执行<strong>执行栈中的同步任务</strong><ol><li>输出<code>1</code></li><li>输出<code>3</code></li></ol></li><li>异步任务放入消息队列中 <ol><li>记录<code>setTimeout(console.log(2), 0)</code></li></ol></li><li>一旦执行栈的所有同步任务执行完毕,系统就会按次序读取<strong>消息队列</strong>中的异步任务,于是被读取的异步任务结束等待状态,进入执行栈,开始执行 <ol><li>输出<code>2</code></li></ol></li></ol><p>由于主线程不断的重复获取任务,执行任务,再获取任务,再执行,所以这种机制被称为<strong>事件循环</strong>(event loop)</p><p><img src="'+d+'" alt="72c5656c1e15a695fb3a3a96ec3381cd2487fb2e" loading="lazy"></p>',13))])}const f=o(c,[["render",g]]);export{C as __pageData,f as default};
