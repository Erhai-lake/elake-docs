import{_ as e,c as d,a6 as c,o as a}from"./chunks/framework.CJ2cRAkn.js";const t="/assets/5a0fd35ae235cf87606604655be62a9b23331738.BrOFVMn_.png",l="/assets/487d4c104afcc86af53403935cf4e007ad5a6654.BXpUi9oz.png",p="/assets/a3a41d415c158cd259a0b3d806b1c38cd82813af.BPhgKZPC.png",i="/assets/3ddfabb0ddc78d271575e4b39c867af17d28fad3.DKs9P7kY.png",s="/assets/fd1b66fbe974c35033144c10591cc7672d0921e8.bLZ7H6bP.png",r="/assets/5dedbf0b5432386b93f25bf3965940d96aa45516.CHgJUQmR.png",n="/assets/e7e2eda44904c9f6b3bd7bc8bddf09fea8da554c.BHLplDir.png",y=JSON.parse('{"title":"位置匹配","description":"","frontmatter":{},"headers":[],"relativePath":"Docs/Knowledge/ProgrammingLanguage/RegularExpression/PositionMatching.md","filePath":"Docs/Knowledge/ProgrammingLanguage/RegularExpression/PositionMatching.md","lastUpdated":1727457588000}'),b={name:"Docs/Knowledge/ProgrammingLanguage/RegularExpression/PositionMatching.md"};function u(f,o,g,h,q,m){return a(),d("div",null,o[0]||(o[0]=[c('<h1 id="位置匹配" tabindex="-1">位置匹配 <a class="header-anchor" href="#位置匹配" aria-label="Permalink to &quot;位置匹配&quot;">​</a></h1><p>:::note 再次强调,正则表达式是匹配模式,要么匹配字符,要么匹配位置.请记住这句话</p><p>然而大部分人学习正则时,对于匹配位置的重视程度没有那么高 :::</p><h2 id="什么是位置" tabindex="-1">什么是位置 <a class="header-anchor" href="#什么是位置" aria-label="Permalink to &quot;什么是位置&quot;">​</a></h2><p>位置是相邻字符之间的位置.例如,下图中箭头所指的地方</p><p><img src="'+t+'" alt="5a0fd35ae235cf87606604655be62a9b23331738" data-fancybox="gallery" loading="lazy"></p><h2 id="如何匹配位置" tabindex="-1">如何匹配位置 <a class="header-anchor" href="#如何匹配位置" aria-label="Permalink to &quot;如何匹配位置&quot;">​</a></h2><p>共有6个锚字符</p><p><code>^</code>,<code>$</code>,<code>\\b</code>,<code>\\B</code>,<code>(?=p)</code>,<code>(?!p)</code></p><h3 id="前两个" tabindex="-1">前两个 <a class="header-anchor" href="#前两个" aria-label="Permalink to &quot;前两个&quot;">​</a></h3><p><code>^</code>(脱字符)匹配开头,在多行匹配中匹配行开头</p><p><code>$</code>(美元符号)匹配结尾,在多行匹配中匹配行结尾</p><p><img src="'+l+'" alt="487d4c104afcc86af53403935cf4e007ad5a6654" data-fancybox="gallery" loading="lazy"></p><h3 id="中间两个" tabindex="-1">中间两个 <a class="header-anchor" href="#中间两个" aria-label="Permalink to &quot;中间两个&quot;">​</a></h3><p><code>\\b</code>是单词边界,具体就是<code>\\w</code>和<code>\\W</code>之间的位置,也包括<code>\\w</code>和<code>^</code>之间的位置,也包括<code>\\w</code>和<code>$</code>之间的位置</p><p>比如一个文件名是<code>[JS] Demo.js</code>中的<code>\\b</code></p><p><img src="'+p+'" alt="a3a41d415c158cd259a0b3d806b1c38cd82813af" data-fancybox="gallery" loading="lazy"></p><p>为什么是这样呢?仔细看看呢~</p><p>首先,我们知道,<code>\\w</code>是字符组<code>[0-9a-zA-Z_]</code>的简写形式,即<code>\\w</code>是字母数字或者下划线的中任何一个字符.而<code>\\W</code>是排除字符组<code>[^0-9a-zA-Z_]</code>的简写形式,即<code>\\W</code>是<code>\\w</code>以外的任何一个字符</p><p>此时我们可以看看<code>[#JS#] #Demo#.#js#</code>中的每一个<code>#</code>是怎么来的</p><ul><li>第一个<code>#</code>,两边是<code>[</code>与<code>J</code>,是<code>\\W</code>和<code>\\w</code>之间的位置</li><li>第二个<code>#</code>,两边是<code>S</code>与<code>]</code>,也就是<code>\\w</code>和<code>\\W</code>之间的位置</li><li>第三个<code>#</code>,两边是空格与<code>D</code>,也就是<code>\\W</code>和<code>\\w</code>之间的位置</li><li>第四个<code>#</code>,两边是<code>o</code>与<code>.</code>,也就是<code>\\w</code>和<code>\\W</code>之间的位置</li><li>第五个<code>#</code>,两边是<code>.</code>与<code>j</code>,也就是<code>\\W</code>和<code>\\w</code>之间的位置</li><li>第六个<code>#</code>,其对应的位置是结尾,但其前面的字符<code>s</code>是<code>\\w</code>,即<code>\\w</code>和<code>$</code>之间的位置</li></ul><p>知道了<code>\\b</code>的概念后,那么<code>\\B</code>也就相对好理解了</p><p><code>\\B</code>就是<code>\\b</code>的反面的意思.非单词边界/例如在字符串中所有位置中.扣掉<code>\\b</code>.剩下的都是<code>\\B</code>的</p><p>具体说来就是<code>\\w</code>与<code>\\w</code>,<code>\\W</code>与<code>\\W</code>,<code>^</code>与<code>\\W</code>,<code>\\W</code>与<code>$</code>之间的位置</p><p>比如上面的例子,把所有<code>\\B</code>替换成<code>#</code></p><p><img src="'+i+'" alt="3ddfabb0ddc78d271575e4b39c867af17d28fad3" data-fancybox="gallery" loading="lazy"></p><h3 id="后两个" tabindex="-1">后两个 <a class="header-anchor" href="#后两个" aria-label="Permalink to &quot;后两个&quot;">​</a></h3><p><code>(?=p)</code>,其中<code>p</code>是一个子模式,即<code>p</code>前面的位置</p><p>比如<code>(?=l)</code>,表示<code>l</code>字符前面的位置,例如</p><p><img src="'+s+'" alt="fd1b66fbe974c35033144c10591cc7672d0921e8" data-fancybox="gallery" loading="lazy">而<code>(?!p)</code>就是<code>(?=p)</code>的反面意思</p><p><img src="'+r+'" alt="5dedbf0b5432386b93f25bf3965940d96aa45516" data-fancybox="gallery" loading="lazy"></p><h2 id="位置的特性" tabindex="-1">位置的特性 <a class="header-anchor" href="#位置的特性" aria-label="Permalink to &quot;位置的特性&quot;">​</a></h2><p>对于位置的理解,我们可以理解成空字符<code> &quot;&quot;</code></p><p>比如<code>&quot;hello&quot;</code>字符串等价于如下的形式</p><p><code>&quot;hello&quot; == &quot;&quot; + &quot;h&quot; + &quot;&quot; + &quot;e&quot; + &quot;&quot; + &quot;l&quot; + &quot;&quot; + &quot;l&quot; + &quot;o&quot; + &quot;&quot;;</code></p><p>也就是</p><p><code>&quot;hello&quot; == &quot;&quot; + &quot;&quot; + &quot;hello&quot;</code></p><p>因此,把<code>/^hello$/</code>写成<code>/^^hello?$/</code>,是没有任何问题的</p><p>:::note 如果你想写屎山代码,甚至可以写成更复杂</p><p><code>/(?=he)^^he(?=\\w)llo$\\b\\b$/</code></p><p><img src="'+n+'" alt="e7e2eda44904c9f6b3bd7bc8bddf09fea8da554c" data-fancybox="gallery" loading="lazy"> :::</p><p>也就是说字符之间的位置,可以写成多个</p><p>把位置理解空字符,是对位置非常有效的理解方式</p>',43)]))}const x=e(b,[["render",u]]);export{y as __pageData,x as default};
